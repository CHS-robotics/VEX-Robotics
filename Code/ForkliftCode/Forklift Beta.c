#pragma config(Sensor, dgtl1,  Top,            sensorTouch)
#pragma config(Sensor, dgtl2,  Bottom,         sensorTouch)
#pragma config(Sensor, dgtl12, Over,           sensorLEDtoVCC)
#pragma config(Motor,  port1,           LDrive,        tmotorVex393_HBridge, openLoop, driveRight)
#pragma config(Motor,  port2,           LiftR,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           LiftL,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LDriveB,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           RDriveB,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          RDrive,        tmotorVex393_HBridge, openLoop, reversed, driveLeft)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool auto = false; //Bool containing if autopilot is enabled
bool overset = false;
bool calset = false;

int count;

void forkUp()
{
	if(count < 127)
	{
		motor[LiftR]= count;
		motor[LiftL]= -count;
		count++;
		delay(20);
	}

	else
	{
		motor[LiftR]= 127;
		motor[LiftL]= -127;
	}
}

void forkDown()
{
	if(count < 127)
	{
		motor[LiftR]= -count;
		motor[LiftL]= count;
		count++;
		delay(20);
	}

	else
	{
		motor[LiftR]= -127;
		motor[LiftL]= 127;
	}
}

task drive()
{
	int threshold = 10;	//Deadzone for joystick. Default=10

	while(true)
	{

		if(auto == false) //Check if autopilot is enabled
		{

			if(abs(vexRT[Ch3]) > threshold || abs(vexRT[Ch2]) > threshold) //Check if the joystick is past the deadzone
			{
				motor[LDrive]= vexRT[Ch3];
				motor[RDrive]= vexRT[Ch2];
				motor[LDriveB]= vexRT[Ch3];
				motor[RDriveB]= vexRT[Ch2];

			}
			else
	    {
	      motor[LDrive]  = 0;
	      motor[RDrive]  = 0;
	      motor[LDriveB]  = 0;
	      motor[RDriveB]  = 0;
	    }

		}
	}
}

task fork()
{
	while(true)
	{
		if(vexRT[Btn6U] == 1 && SensorValue[Top] == 0)
		{
			forkUp();
		}

		else if(vexRT[Btn5U] == 1 && SensorValue[Bottom] == 0)
		{
			forkDown();
		}

		else if(vexRT[Ch3] > 10 && vexRT[Btn8D] == 1 && SensorValue[Top] == 0 && overset==false)
		{
			auto = true;
			motor[LiftR] = vexRT[Ch3];
			motor[LiftL] = -vexRT[Ch3];
		}

		else if(vexRT[Ch3] < 10 && vexRT[Btn8D] == 1 && SensorValue[Bottom] == 0 && overset==false)
		{
			auto = true;
			motor[LiftR] = vexRT[Ch3];
			motor[LiftL] = -vexRT[Ch3];
		}

		else if(abs(vexRT[Ch3]) > 10 && vexRT[Btn8D] == 1 && overset==true)
		{
			auto = true;
			motor[LiftR] = vexRT[Ch3];
			motor[LiftL] = -vexRT[Ch3];
		}
		else
		{
			auto = false;
			motor[LiftR]= 0;
			motor[LiftL]= 0;
			count = 20;
		}
	}
}

task override()
{
	while(true)
	{
		if(vexRT[Btn5D] == 1 && overset == false)
		{
			overset=true;
			waitUntil(vexRT[Btn5U] == 0);
		}

		if(vexRT[Btn5D] == 1 && overset == true)
		{
			overset=false;
			waitUntil(vexRT[Btn5U] == 0);
		}

		if(overset==false)
		{
			SensorValue[Over]=0;
		}

		else
		{
			SensorValue[Over]=1;
		}
	}
}

task blink()
{
	while(true)
	{
		if(calset==false)
		{

		}

		else
		{
			SensorValue[Over] = true;
			wait1Msec(1000);
			SensorValue[Over] = false;
			wait1Msec(1000);
			//SensorValue[Over]=1;
			//delay(200);
			//SensorValue[Over]=0;
			//delay(200);
		}
	}
}

task calibrate()
{
	while(true)
	{
		if(vexRT[Btn6D] == 1 && calset == false)
		{
			calset=true;
			startTask(blink);
			waitUntil(vexRT[Btn6U] == 0);
		}

		if(vexRT[Btn6D] == 1 && calset == true)
		{
			calset=false;
			stopTask(blink);
			waitUntil(vexRT[Btn6U] == 0);
		}
	}
}

task cal()
{
	int threshold = 10;	//Deadzone for joystick. Default=10

	while(true)
	{
		if(abs(vexRT[Ch3Xmtr2]) > threshold && calset == true)
		{
			motor[LiftL]  = vexRT[Ch3Xmtr2];
		}

		if(abs(vexRT[Ch2Xmtr2]) > threshold && calset == true)
		{
			motor[LiftR]  = vexRT[Ch2Xmtr2];
		}
	}
}

task main()
{
	clearTimer(T1);

	startTask(drive);
	startTask(fork);
	startTask(override);
	startTask(cal);
	startTask(calibrate);

	while(true)
	{

	}
}
